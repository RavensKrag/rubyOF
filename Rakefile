require 'rake/testtask'
require 'rake/clean'

require 'fileutils'
require 'open3'
require 'yaml' # used for config files
require 'json' # used to parse Clang DB


require './common'
# ^ this file declares GEM_ROOT constant, other constants, and a some functions

load './rake/helper_functions.rb'
load './rake/clean_and_clobber.rb'



# ==== rake argument documentation ====
# :rubyOF_project		name of project (if under project directory)
#                         OR
#                    full path to project (if stored elsewhere)
# =====================================



# generate depend file for gcc dependencies
# sh "gcc -MM *.c > depend"

load './rake/oF_core.rake'
load './rake/oF_deps.rake'
load './rake/oF_project.rake'
load './rake/extension.rake'


# defines RubyOF::Build.create_project and RubyOF::Build.load_project
require File.join(GEM_ROOT, 'build', 'build.rb')







module Monad
	class << self
		# maybe monad that understand Ruby has exceptions
		# contex: object to call the methods on
		# list:   lisp-style list of functions (nested list)
		#         eg) [[:foo, "hello", 2,3], [:baz, "world", 4,5, false]]
		def maybe_e(context, list)
			list.each_with_index do |fx, i|
				begin
					context.send *fx
				rescue => e
					puts "ERROR: Exception on function @ index #{i} in Maybe monad."
					puts "=>     #{list[i]}"
					raise e
					
					# break
				end
			end
		end
	end
end


module RubyOF
	module Build

class ExtensionBuilder	
	def initialize(project_name)
		raise "ERROR: no project name specified" if project_name.nil?
		# ^ Need to do this, because of how Rake tasks work
		#   It is always possible to call a rake task that requires arguments
		#   with no arguments at all.
		# But the exception handling needs to be here,
		# because the constructor is called in many tasks.
		# (code duplication would be a hassle...)
		
		name, path = RubyOF::Build.load_project(project_name)
		# name of the project
		# (should be the same as the directory name)
		@project_name = name
		
		# root directory for the project
		@project_path = path
		
		
		
		# path to most of the .o files generated by core extension build
		@core_path = File.join(GEM_ROOT, 'ext', NAME)
		
		# path to the app.o (generated for this RubyOF project)
		@app_path  = File.join(@project_path, 'ext', 'window')
		
		
		
		# 'extconf_variables.yaml' files
		# (build system variable dumps)
		@main_build_var_file = File.join(
			GEM_ROOT, 'ext', NAME, 'extconf_variables.yaml'
		)
		
		@project_build_var_file = File.join(
			@app_path, 'extconf_variables.yaml'
		)
		
		
		
		# where do the data files for the project go?
		@data_path      = File.join(
			@project_path, 'bin', 'data'
		)
		
		# where is the data path constant defined?
		# (C++ header. #defines constant for oF at C++ level)
		# [this file is automatically generated by the rakefile build system]
		@data_path_file = File.join(
			@app_path, 'constants', 'data_path.h'
		)
		
		
		
		
		
		@so_paths = {
			# :wrapper = core Rice wrapper code
			# :project = intermediate .so for project-specific code
			# :final   = output .so that combines both :wrapper and :project
			:wrapper => File.join(GEM_ROOT, 'ext', NAME, "#{NAME}.so"),
			:project => File.join(@app_path, "#{NAME}.so"),
			:final   => File.join(@app_path, 'final', "#{NAME}.so"),
			
			
			# The final output goes here,
			# to be loaded by the Ruby interpreter
			:install => File.join(@project_path, 'bin', 'lib', "#{NAME}.so")
		}
	# NOTE: The wrapper build, project build, and final link can all live in harmory. No build phase will clobber any parts needed by other phase.
		
	end
	
	# ------------------------
	
	
	
	
	# patch c constant file with proper data path
	# 
	# deps: @data_path_file    (variable)
	#       @data_path         (variable)
	def create_data_path_file
		# NOTE: only need to run this method when @data_path is changed
		puts "=== create file"
		
		FileUtils.mkdir_p File.dirname @data_path_file
		
		File.open(@data_path_file, 'w') do |f|
			f.puts "#define DATA_PATH \"#{@data_path}\""
		end
	end
	
	
	# # NOTE: generates project-specific 'app.o' file
	# desc "build RubyOF project-specific C++ code (linux)"
	def build
		puts "=== build"
		
		# check if the 
		# is newer than
		# the intermidate .so from the main build
			# "ext/#{NAME}/#{NAME}.so"
		
		
		
		puts "Building project-specific C++ code..."
		Dir.chdir(@app_path) do
			puts "=== Generating makefile for project '#{@project_name}'"
			run_i "ruby extconf.rb"
			# ^ dumps log of variables to @project_build_var_file
			
			puts "=== Building project..."
			run_i "make"
			# ^ creates .so @ this location => @so_paths[:project]
		end
	end
	
	# desc "link final dynamic library (linux)"
	#   Combines obj files from Rice wrapper build
	#   and obj files from project-specific build
	#   into one cohesive whole
	# 
	# ASSUME: main extconf.rb and project-specific extconf.rb have run, and have succesfully outputed their variable files.
	# NOTE: Only need to run this if 'build' has changed some files
	def link
		puts "=== Linking final dynamic library..."
		
		# === Create a place for the final .so to go
		# Need to have a copy somewhere other than the install location
		# because other projects may need to move into that space.
		FileUtils.mkdir_p  File.dirname @so_paths[:final]
		
		
		# === Load in environment variables
		puts "loading main extconf variables..."
		main_vars = load_extconf_data(@main_build_var_file)
		
		puts "loading #{NAME} project extconf variables..."
		project_vars = load_extconf_data(@project_build_var_file)
		
		
		# === Expand obj paths to full paths
		main_objs = 
			main_vars['$objs'].collect{ |x|
				File.join(@core_path, x)
			}
		
		
		# === Mix in obj paths from the project
		app_objs = 
			project_vars['$objs'].collect{ |x|
				File.join(@app_path, x)
			}
		
		
		# NOTE: The extconf.rb build files constantly relink the .so files, so their timestamps are not a reliable indicator of when the last build occurred. You must observe the time on the .o files instead.
		timestamps = 
			(main_objs + app_objs).collect{ |x|
				Pathname.new(x)
			}.collect{ |path|
				path.mtime # get last modification time for file
			}.sort # chronological order (oldest first)
		puts "Dependency timestamps:"
		p timestamps
		# NOTE: older < newer
		
		
		
		
		# only perform the link when the component obj files have been updated
		# (one or more .o files are newer than the .so file)
		# [aka, skip linking when .so is newer than the newest .o file]
		so_location = Pathname.new(@so_paths[:final])
		
		print "Timestamp for final .so: "
		p so_location.mtime if so_location.exist?
		
		if so_location.exist? and timestamps.last < so_location.mtime
			puts "skipping link phase"
			return
			# use 'return' instead of 'raise' to continue the build
		end
		
		
		Dir.chdir(@app_path) do
			# TODO: need to allow linking of additional stuff as well (any additional flags that might be set by the RubyOF project specific build)
			# TOOD: Figure out if the flags used by the app are always a superset of the flags used by main (may not be a proper superset)
			
			
			
			# === Assemble the base link command
			puts "reading gem environment..."
			env = read_gem_env()
			
			# --- Extract exec_prefix from ruby environment data
			# 'exec_prefix' is the directory that contains 'bin/ruby'
			# As such, you just need to step up two levels in the filesystem.
			exec_prefix =  File.expand_path '../..', env["RUBY EXECUTABLE"]
			lib_dir = "#{exec_prefix}/lib"
			
			
			final_link_command = 
				[
					main_vars['$LDSHARED_CXX'],
					'-o', # have to supply this manually
					"./final/#{NAME}.so",
					app_objs,
					main_objs,
					"-L. -L#{lib_dir} -Wl,-R#{lib_dir}",
					main_vars['$LDFLAGS'],
					main_vars['$DLDFLAGS'],
					main_vars['$libs'],
					main_vars['$LIBRUBYARG'],
					main_vars['$LIBS']
				].join(' ')
			
			
			
			# === Makefile variable replacement
			# just blank out ${ORIGIN}
			# That seems to be what the original extconf.rb build did.
			final_link_command.gsub! "${ORIGIN}", ''
			
			
			
			# === Display link command in terminal
			# (substitute [GEM_ROOT] for the root path, like in 'run_i')
			# (substitution is for display purposes only)
			puts "Performing final link..."
			puts final_link_command.gsub GEM_ROOT, '[GEM_ROOT]'
			
			
			# === Execute the final link
			run_i final_link_command
		end
		
		
		
		puts "Final link complete!"
	end
	
	private
	
	def load_extconf_data(path_to_yaml_dump)
		extconf_data = YAML.load_file(path_to_yaml_dump)
		extconf_variable_names, extconf_variable_hash = extconf_data
		
		return extconf_variable_hash
	end
	
	# Turns out, the output of the command 'gem env' is basically YAML.
	# As such, you can load that right up as a string,
	# in order to get information about the enviornemnt.
	def read_gem_env
		# --- Gotta do a little bit of reformatting of this data...
			# Top level data structure is an Array of Hash objects.
			# "flatten" it out, merging all hashes together,
			# and removing the containing Array.
		env = YAML.load `gem env`
		env = 
			env["RubyGems Environment"]
			.inject(Hash.new){ |hash, x|
				hash.merge! x
			}
		# p env
		
		return env
	end
	
	public
	
	
	
	
	
	def run_tests
		puts "=== running tests"
		
		symbols = self.methods.grep /test_/
		p symbols
		
		symbols.each do |sym|
			self.send sym
		end
	end
	
		# Check final dynamic libary for symbols that will only exist
		# when the final link is performed correctly.
		# desc "make sure final link works as expected (linux)"
		def test_final_link
			puts "--- testing: make sure final link has happened"
			
			# The test symbol sholud be something that only exists
			# in the base build, and not the project build.
			# Thus, the presense of this symbol in the final linked product
			# confirms that the link has succeded.
			
			
			# --- first, make sure the baseline lib actually exists
			#     (can't compare with something that's not there)
			path = Pathname.new(@so_paths[:wrapper])
			unless path.exist?
				raise "ERROR: Baseline lib not found @ #{path}"
			end
			
			
			# --- check the output location too
			path = Pathname.new(@so_paths[:final])
			unless path.exist?
				raise "ERROR: Dynamic lib from final link not found @ #{path}"
			end
			
			
			# --- perform the main checks
			sym      = "Launcher"
			test_cmd = "nm -C #{NAME}.so  | grep #{sym}"
			
			# baseline
			cmd1 = nil
			Dir.chdir(File.dirname(@so_paths[:wrapper])) do
				cmd1 = `#{test_cmd}` # run test command in shell
			end
			
			# final link
			cmd2 = nil
			Dir.chdir(File.dirname(@so_paths[:final])) do
				cmd2 = `#{test_cmd}` # run test command in shell
			end
			
			
			# p cmd1
			# p cmd2
			if cmd1.nil? or cmd2.nil?
				raise "ERROR: unexpected problem while inspecting final product."
			elsif cmd1 == ''
				raise "ERROR: symbol '#{sym}' not present in baseline lib."
			elsif cmd2 == '' # at this point, no error for baseline lib
				raise "ERROR: final .so did not contain symbol '#{sym}' as expected"
			else
				puts "no problems with final link"
			end
		end
		
		# Check if symbol is undefined, rather than merely if it is present.
		# desc "Make sure app factory has been linked into final product (linux)"
		def test_app_factory_link
			puts "--- testing: looking for 'app factory' symbol"
	
			sym      = "appFactory_create"
			test_cmd = "nm -C #{NAME}.so  | grep #{sym}"
			
			
			out = nil
			
			Dir.chdir(File.dirname(@so_paths[:final])) do
				out = `#{test_cmd}`
			end
			
			
			
			
			if out.nil?
				raise "ERROR: unexpected problem while inspecting final product."
			elsif out == ''
				raise "ERROR: symbol '#{sym}' not found in final dynamic library"
			elsif out.include? 'U'
				# ex)  U appFactory_create(Rice::Object)
				raise "ERROR: symbol '#{sym}' found, but was undefined"
			else
				# No problems!
				puts "no problems - appFactory linked correctly"
			end
		end
	
	
	
	# desc "move completed dynamic library to final location (linux)"
	# task :install do
	def install
		puts "=== install"
		
		src = @so_paths[:final]
		dst = @so_paths[:install]
		
		puts "Moving completed dynamic library to '#{dst}'".gsub(GEM_ROOT, "[GEM_ROOT]")
		# copy dynamic lib into final location
		FileUtils.mkdir_p(Pathname.new(dst).dirname)
		FileUtils.cp(src, dst)
	end
	
	
	
	
	# ------------------------
	
	def main
		Monad.maybe_e self, [
			[:create_data_path_file],
			[:build],
			[:link],
			[:run_tests],
			[:install],
		]
	end
	
	def clean
		Dir.chdir(@app_path) do
			begin 
				run_i "make clean"
			rescue StandardError => e
				# FIXME: Can't seem to catch, suppress, and continue
				puts "nothing to clean for #{@app_path}"
			end
		end
		
		# clean files
		[
			@project_build_var_file,
			@data_path_file,
			@so_paths[:final],
			# @so_paths[:project], # should already be cleaned by 'make clean'
		].each do |filepath|
			FileUtils.rm filepath if File.exists? filepath
		end
		
		# clean directories
		[
			File.dirname(@data_path_file),
			File.dirname(@so_paths[:final])
		].each do |filepath|
			FileUtils.rm_rf filepath if Dir.exists? filepath
		end
	end
	
	def clobber
		self.clean
		
		# clobber files
		[
			@so_paths[:install],
			File.join(@app_path, "Makefile")
		].each do |file_to_be_cleaned|
			FileUtils.rm file_to_be_cleaned if File.exist? file_to_be_cleaned
		end
	end
	
end


end
end

namespace :cpp_project do
	
	task :build, [:rubyOF_project] do |t, args|
		obj = RubyOF::Build::ExtensionBuilder.new(args[:rubyOF_project])
		obj.main
	end	
	
	task :clean, [:rubyOF_project] do |t, args|
		obj = RubyOF::Build::ExtensionBuilder.new(args[:rubyOF_project])
		obj.clean
	end
	
	task :clobber, [:rubyOF_project] => :clean do |t, args|
		obj = RubyOF::Build::ExtensionBuilder.new(args[:rubyOF_project])
		obj.clobber
	end
	
	
end




# project-specific C++ code that gets built as a separate Ruby extension
namespace :cpp_callbacks do
	task :build, [:rubyOF_project] do |t, args|
		name_or_path = args[:rubyOF_project]
		name, path = RubyOF::Build.load_project(name_or_path)
		
			# TODO: consider turning #load_project into a block-taking method
			# I think that style would let you omit parameters if you wanted?
			# (e.g. I don't need the 'name' this time around)
		
		# PATH/ext/callbacks
		build_dir = File.join(path, 'ext', 'callbacks')
		
		# Generate makefile
		# and build the extension
		puts "=== Building project-specific C++ into a separate extension"
		
		Dir.chdir build_dir do
			run_i "ruby extconf.rb"
			run_i "make"
		end
		
	end
	
	task :clean, [:rubyOF_project] do |t, args|
		name_or_path = args[:rubyOF_project]
		name, path = RubyOF::Build.load_project(name_or_path)
		build_dir = File.join(path, 'ext', 'callbacks')
		
		Dir.chdir(build_dir) do
			begin 
				run_i "make clean"
			rescue StandardError => e
				# FIXME: Can't seem to catch, suppress, and continue
				puts "nothing to clean for #{build_dir}"
			end
		end
	end
	
	task :clobber, [:rubyOF_project] => :clean do |t, args|
		name_or_path = args[:rubyOF_project]
		name, path = RubyOF::Build.load_project(name_or_path)
		build_dir = File.join(path, 'ext', 'callbacks')
		
		[
			"Makefile"
		].each do |file_to_be_cleaned|
			Dir.chdir(build_dir) do
				FileUtils.rm file_to_be_cleaned if File.exist? file_to_be_cleaned
			end
		end
	end
end







module RubyOF
	module Build

class RubyBundlerAutomation
	def initialize
		
	end
	
	def install_core
		# begin
			puts "Bundler: Installing core dependencies"
			bundle_install(GEM_ROOT)
		# rescue StandardError => e
		# 	puts "Bundler had an error."
		# 	puts e
		# 	puts e.backtrace
		# 	exit
		# end
	end
	
	def uninstall_core
		bundle_uninstall(GEM_ROOT)
	end
	
	def install_project(path_or_name)
		begin
			name, path = RubyOF::Build.load_project(path_or_name)
			
			puts "Bundler: Installing dependencies for project '#{name}'"
			bundle_install(path)
		rescue StandardError => e
			puts "Bundler had an error."
			exit
		end
	end
	
	def uninstall_project(path_or_name)
		name, path = RubyOF::Build.load_project(path_or_name)
		bundle_uninstall(path)
	end
	
	private
	
	def bundle_install(path)
		Dir.chdir path do
			# run_i "unbuffer bundle install"
			# # NOTE: unbuffer does work here, but it assumes that you have that utility installed, and it is not installed by default
			# 	# sudo apt install expect
			
			
			run_pty "bundle install"
		end
	end
	
	def bundle_uninstall(path)
		Dir.chdir path do
			FileUtils.rm_rf "./.bundle"      # settings directory
			FileUtils.rm    "./Gemfile.lock" # lockfile
		end
	end
end

end
end

# === Manage ruby-level code
namespace :ruby do
	desc "testing"
	task :run, [:rubyOF_project] do |t, args|
		name, path = RubyOF::Build.load_project(args[:rubyOF_project])
		Dir.chdir path do
			puts "ruby level execution"
			
			exe_path = "./lib/main.rb"
			
			cmd = [
				'GALLIUM_HUD=fps,VRAM-usage',
				"ruby #{exe_path}"
			].join(' ')
			
			Kernel.exec(cmd)
		end
	end
	
	desc "testing"
	task :debug, [:rubyOF_project] do |t, args|
		name, path = RubyOF::Build.load_project(args[:rubyOF_project])
		Dir.chdir path do
			puts "ruby level execution"
			
			exe_path = "./lib/main.rb"
			p exe_path
			puts "Path to core file above."
			puts "Type: run 'PATH_TO_CORE_FILE'"
			puts "Remember: type 'q' to exit GDB."
			puts "=============================="
			puts ""
			Kernel.exec "gdb ruby"
		end
	end
	
	
	# manage ruby-level dependencies
	namespace :deps do
		obj = RubyOF::Build::RubyBundlerAutomation.new
		
		namespace :core do
			task :install do
				obj.install_core
			end
			
			task :uninstall do
				obj.uninstall_core
			end
		end
		
		
		namespace :project do
			task :install, [:rubyOF_project] do |t, args|
				obj.install_project(args[:rubyOF_project])
			end
			
			task :uninstall, [:rubyOF_project] do |t, args|
				obj.uninstall_project(args[:rubyOF_project])
			end
		end
	end
	
	
end






# cpp_wrapper_code   build / clean
# cpp_callbacks      build / clean / clobber
# cpp_project        build / clean / clobber


# # clean
# 	rake clean
# 	rake clean_cpp_wrapper[rubyOF_project]
# 	rake clean_project[rubyOF_project]
	
# 	rake oF:clean
# 		rake oF_deps:clean
# 			rake oF_deps:kiss:clean
# 			rake oF_deps:tess2:clean
	
# 	rake oF_project:clean
# 	rake oF_project:static_lib:clean
	
# 	rake cpp_wrapper_code:clean
	
# 	rake cpp_project:clean[rubyOF_project]
	
# 	rake cpp_callbacks:clean[rubyOF_project]

	

# # clobber
# 	rake clobber
	
# 	rake oF_deps:clobber
# 		rake oF_deps:kiss:clobber
# 		rake oF_deps:tess2:clobber
	
# 	rake cpp_project:clobber[rubyOF_project]
	
# 	rake cpp_callbacks:clobber[rubyOF_project]





# clean just a few things
desc "For reversing :build_cpp_wrapper"
task :clean_cpp_wrapper, [:rubyOF_project] => [
	'cpp_wrapper_code:clean',
	'cpp_project:clean',
	'cpp_callbacks:clean'
]

desc "For reversing :build_project"
task :clean_project, [:rubyOF_project] => [
	'cpp_project:clean',
	'cpp_callbacks:clean'
]

desc "For reversing :build_project"
task :clobber_project, [:rubyOF_project] => [
	'cpp_project:clobber',
	'cpp_callbacks:clobber'
] do |t, args|
	name, path = RubyOF::Build.load_project(args[:rubyOF_project])
	
	filepath = (Pathname.new(path) + 'Gemfile.lock')
	FileUtils.rm filepath if filepath.exist?
end





# add dependencies to default 'clean' / 'clobber' tasks
# NOTE: Don't edit the actual body of the task
task :clean   => [
	'oF_project:clean',
	'cpp_wrapper_code:clean',
	'cpp_project:clean',  # requires :rubyOF_project var
	'cpp_callbacks:clean' # requires :rubyOF_project var
]
task :clobber => ['oF_deps:clobber', 'oF:clean']



# TODO: Update clean tasks to remove the makefile after running "make clean"
# (the main Makefile is removed on 'clean', so I think all other auto-generated makefiles should follow suit)



desc "Set up environment on a new machine."
task :setup => [
	# 'oF:download_libs',
	'oF_deps:inject', # NOTE: injecting will always force a new build of oF core
	'oF:build',
	'oF_project:build'
] do
	FileUtils.mkdir_p "bin/data"
	FileUtils.mkdir_p "bin/lib" # <-- DYNAMIC_LIB_PATH
	FileUtils.mkdir_p "bin/projects"
	FileUtils.mkdir_p "bin/projects/testProjectRuby/bin"
	FileUtils.mkdir_p "bin/projects/testProjectRuby/ext"
	FileUtils.mkdir_p "bin/projects/testProjectRuby/lib"
end



# desc "Copy oF dynamic libs to correct location"
task :install_oF_dynamic_libs do
	puts "=== Copying OpenFrameworks dynamic libs..."
	
	# -rpath flag specifies where to look for dynamic libraries
	# (the system also has some paths that it checks for, but these are the "local dlls", basically)
	
	# NOTE: DYNAMIC_LIB_PATH has been passed to -rpath
	# (specified in extconf.rb)
	
	src = File.expand_path(
		        "./libs/fmodex/lib/#{PLATFORM}/libfmodex.so",
	           OF_ROOT
	      )
	dest = DYNAMIC_LIB_PATH
	FileUtils.copy(src, dest)
	
	# (actual DYNAMIC_LIB_PATH directory created explictly in :setup task above)
	# (does not reference the constant)
	
	# TODO: consider copying the ext/oF_apps/testApp/bin/data/ directory as well
end



# For working on a normal OpenFrameworks project in pure C++
desc "Build a normal OpenFrameworks project in pure C++"
task :build_cpp => ['oF:build', 'oF_project:build']



# For integrating Rice bindings with the current RubyOF project
# (can edit addons, oF core, oF project, Rice bindings, or RubyOF project)
# 
# Assumes 'setup' has been run.
# 
# Build dependencies shifted from explict to implied, (assumes task has run)
# so that you don't duplicate the work being done in :setup.
# This way, the build process will go a little faster.
desc "For updating Rice code, and testing with current RubyOF project"
task :build_cpp_wrapper, [:rubyOF_project] => [
	'oF:build',
	
	'oF_project:build',                  # implicitly requires oF:build
	'oF_project:export_build_variables', # implicitly requires oF_project:build
	'oF_project:static_lib:build',
	
	'cpp_wrapper_code:build', # implicitly requires oF_project:build
	# ^ multiple steps:
	#   +  extconf.rb -> makefile
	#   +  run the makefile -> build ruby dynamic lib (.so)
	#   +  move ruby dynamic lib (.so) into proper position
	#   +  ALSO rebuilds the clang symbol DB as necessary.
	
	:install_oF_dynamic_libs,
	
	
	'cpp_project:build',
	'cpp_callbacks:build'
] do
	
	puts ">>> BUILD COMPLETE <<<"
	
end


# For using stable bindings with a custom blend of C++ and Ruby
# (can edit addons, or RubyOF project)
# 
# Assumes 'setup' has been run
# Assumes 'build_cpp_wrapper' has been run
desc "For using stable bindings with a custom blend of C++ and Ruby"
task :build_project, [:rubyOF_project] => [
	'oF_project:build',                  # implicitly requires oF:build
	'oF_project:export_build_variables', # implicitly requires oF_project:build
	'oF_project:static_lib:build',
	
	:install_oF_dynamic_libs,
	
	'cpp_project:build',
	'cpp_callbacks:build'
] do |t, args|
	puts ">>> BUILD COMPLETE <<<"
end

# NOTE: parameters to rake task are passed to all dependencies as well
# source: https://stackoverflow.com/questions/12612323/rake-pass-parameters-to-dependent-tasks



# --- pathway ---
desc "Build up from a newly cloned repo"
task :full_build, [:rubyOF_project] => [
	:setup,
	:build_cpp_wrapper,
	:build_project
]






# (tasks that do not need the 'project' argument will ignore it)
# desc "Run default build task (:build_cpp_wrapper)"
# task :build, [:rubyOF_project] => :build_cpp_wrapper
desc "Run default build task (:build_project)"
task :build, [:rubyOF_project] => :build_project



# task :run => 'oF_project:run'

desc "Run the entire project, through the ruby level"
task :run, [:rubyOF_project] => 'ruby:run'
	# can't just say 'run' any more.
	# need to specify what project is being run

task :build_and_run, [:rubyOF_project]  => [:build, :run] do
	
end





desc "Assumes build options are set to make 'Debug' target"
task :debug_project => [
	'oF:build',
	'oF_project:build',                  # implicitly requires oF:build
	'oF_project:debug'
] do
	
end

desc "Debug application through the Ruby level with GDB"
task :debug, [:rubyOF_project]  => 'ruby:debug'





# TODO: move this into the oF_deps namespace, and then consolodate all path definitions.
# NOTE: Assumes you're running on Linux
desc "Examine compiled libraries (linux)"
task :examine, [:library_name] do |t, args|
	name = args[:library_name].to_sym
	path =
		case name
			when :kiss
				"ext/oF_deps/master/custom/kiss/custom_build/lib/libkiss.a"
			when :tess2
				"ext/oF_deps/master/custom/tess2/lib/#{PLATFORM}/libtess2.a"
			when :oF_core
				"ext/openFrameworks/libs/openFrameworksCompiled/lib/linux64/libopenFrameworks.a"
			when :oF_project
				if OF_DEBUG
					"ext/oF_apps/#{OF_SKETCH_NAME}/bin/#{OF_SKETCH_NAME}_debug"
				else
					"ext/oF_apps/#{OF_SKETCH_NAME}/bin/#{OF_SKETCH_NAME}"
				end
			when :oF_project_lib
				"ext/oF_apps/#{OF_SKETCH_NAME}/lib/libOFSketch.a"
			when :rubyOF
				"ext/rubyOF/rubyOF.so"
		end
	
	case File.extname path
		when ".a"
			run_i "nm -C #{path}"
		when ".so"
			run_i "nm -C -D #{path}"
		else # linux executable
			run_i "nm -C #{path}"
	end
	
	# # the -C flag is for de-mangling the C++ function names
	# run_i "nm -C #{path_to_lib}"
	
	# # this command will let you see inside an .so
	# # nm -C -D libfmodex.so
	# # src: http://stackoverflow.com/questions/4514745/how-do-i-view-the-list-of-functions-a-linux-shared-library-is-exporting
end

