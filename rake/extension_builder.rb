
module Monad
	class << self
		# maybe monad that understand Ruby has exceptions
		# contex: object to call the methods on
		# list:   lisp-style list of functions (nested list)
		#         eg) [[:foo, "hello", 2,3], [:baz, "world", 4,5, false]]
		def maybe_e(context, list)
			list.each_with_index do |fx, i|
				begin
					context.send *fx
				rescue => e
					puts "ERROR: Exception on function @ index #{i} in Maybe monad."
					puts "=>     #{list[i]}"
					raise e
					
					# break
				end
			end
		end
	end
end


module RubyOF
	module Build

class ExtensionBuilder	
	def initialize(project_name)
		raise "ERROR: no project name specified" if project_name.nil?
		# ^ Need to do this, because of how Rake tasks work
		#   It is always possible to call a rake task that requires arguments
		#   with no arguments at all.
		# But the exception handling needs to be here,
		# because the constructor is called in many tasks.
		# (code duplication would be a hassle...)
		
		name, path = RubyOF::Build.load_project(project_name)
		# name of the project
		# (should be the same as the directory name)
		@project_name = name
		
		# root directory for the project
		@project_path = path
		
		
		
		# path to most of the .o files generated by core extension build
		@core_path      = File.join(GEM_ROOT, 'ext', NAME)
		
		# path to the app.o (generated for this RubyOF project)
		@app_path       = File.join(@project_path, 'ext', 'window')
		
		# .a for the addons for this particular project
		@addon_lib_file = File.join(@project_path, 'ext', 'addons_app', 
												'testApp', 'lib', 'libOF_ProjectAddons.a'
		)
		
		# TODO: make sure @addon_lib_file is (1) a file that (2) exists before continuining.
		
		
		# 'extconf_variables.yaml' files
		# (build system variable dumps)
		@main_build_var_file = File.join(
			GEM_ROOT, 'ext', NAME, 'extconf_variables.yaml'
		)
		
		@project_build_var_file = File.join(
			@app_path, 'extconf_variables.yaml'
		)
		
		
		
		# where do the data files for the project go?
		@data_path      = File.join(
			@project_path, 'bin', 'data'
		)
		
		# where is the data path constant defined?
		# (C++ header. #defines constant for oF at C++ level)
		# [this file is automatically generated by the rakefile build system]
		@data_path_file = File.join(
			@app_path, 'constants', 'data_path.h'
		)
		
		
		
		
		
		@so_paths = {
			# :wrapper = core Rice wrapper code
			# :project = intermediate .so for project-specific code
			# :final   = output .so that combines both :wrapper and :project
			:wrapper => File.join(GEM_ROOT, 'ext', NAME, "#{NAME}.so"),
			:project => File.join(@app_path, "#{NAME}.so"),
			:final   => File.join(@app_path, 'final', "#{NAME}.so"),
			
			
			# The final output goes here,
			# to be loaded by the Ruby interpreter
			:install => File.join(@project_path, 'bin', 'lib', "#{NAME}.so")
		}
	# NOTE: The wrapper build, project build, and final link can all live in harmory. No build phase will clobber any parts needed by other phase.
		
	end
	
	# ------------------------
	
	
	
	
	# patch c constant file with proper data path
	# 
	# deps: @data_path_file    (variable)
	#       @data_path         (variable)
	def create_data_path_file
		# NOTE: only need to run this method when @data_path is changed
		puts "=== create file"
		
		FileUtils.mkdir_p File.dirname @data_path_file
		
		File.open(@data_path_file, 'w') do |f|
			f.puts "#define DATA_PATH \"#{@data_path}\""
		end
	end
	
	
	# # NOTE: generates project-specific 'app.o' file
	# desc "build RubyOF project-specific C++ code (linux)"
	def build
		puts "=== build"
		
		# check if the 
		# is newer than
		# the intermidate .so from the main build
			# "ext/#{NAME}/#{NAME}.so"
		
		
		
		puts "Building project-specific C++ code..."
		Dir.chdir(@app_path) do
			puts "=== Generating makefile for project '#{@project_name}'"
			run_i "ruby extconf.rb"
			# ^ dumps log of variables to @project_build_var_file
			
			puts "=== Building project..."
			run_i "make"
			# ^ creates .so @ this location => @so_paths[:project]
		end
	end
	
	# desc "link final dynamic library (linux)"
	#   Combines obj files from Rice wrapper build
	#   and obj files from project-specific build
	#   into one cohesive whole
	# 
	# ASSUME: main extconf.rb and project-specific extconf.rb have run, and have succesfully outputed their variable files.
	# NOTE: Only need to run this if 'build' has changed some files
	def link
		puts "=== Linking final dynamic library..."
		
		# === Create a place for the final .so to go
		# Need to have a copy somewhere other than the install location
		# because other projects may need to move into that space.
		FileUtils.mkdir_p  File.dirname @so_paths[:final]
		
		
		# === Load in environment variables
		puts "loading main extconf variables..."
		main_vars = load_extconf_data(@main_build_var_file)
		
		puts "loading #{NAME} project extconf variables..."
		project_vars = load_extconf_data(@project_build_var_file)
		
		
		# === Expand obj paths to full paths
		main_objs = 
			main_vars['$objs'].collect{ |x|
				File.join(@core_path, x)
			}
		
		
		# === Mix in obj paths from the project
		app_objs = 
			project_vars['$objs'].collect{ |x|
				File.join(@app_path, x)
			}
		
		
		# NOTE: The extconf.rb build files constantly relink the .so files, so their timestamps are not a reliable indicator of when the last build occurred. You must observe the time on the .o files instead.
		timestamps = 
			(main_objs + app_objs).collect{ |x|
				Pathname.new(x)
			}.collect{ |path|
				path.mtime # get last modification time for file
			}.sort # chronological order (oldest first)
		puts "Dependency timestamps:"
		p timestamps
		# NOTE: older < newer
		
		
		
		
		# only perform the link when the component obj files have been updated
		# (one or more .o files are newer than the .so file)
		# [aka, skip linking when .so is newer than the newest .o file]
		so_location = Pathname.new(@so_paths[:final])
		
		print "Timestamp for final .so: "
		p so_location.mtime if so_location.exist?
		
		if so_location.exist? and timestamps.last < so_location.mtime
			puts "skipping link phase"
			return
			# use 'return' instead of 'raise' to continue the build
		end
		
		
		Dir.chdir(@app_path) do
			# TODO: need to allow linking of additional stuff as well (any additional flags that might be set by the RubyOF project specific build)
			# TOOD: Figure out if the flags used by the app are always a superset of the flags used by main (may not be a proper superset)
			
			
			
			# === Assemble the base link command
			puts "reading gem environment..."
			env = read_gem_env()
			
			# --- Extract exec_prefix from ruby environment data
			# 'exec_prefix' is the directory that contains 'bin/ruby'
			# As such, you just need to step up two levels in the filesystem.
			exec_prefix =  File.expand_path '../..', env["RUBY EXECUTABLE"]
			lib_dir = "#{exec_prefix}/lib"
			
			
			final_link_command = 
				[
					main_vars['$LDSHARED_CXX'],
					'-o', # have to supply this manually
					"./final/#{NAME}.so",
					app_objs,
					main_objs,
					"-L. -L#{lib_dir} -Wl,-R#{lib_dir}",
					main_vars['$LDFLAGS'],
					@addon_lib_file,
					main_vars['$DLDFLAGS'],
					main_vars['$libs'],
					main_vars['$LIBRUBYARG'],
					main_vars['$LIBS']
				].join(' ')
			
			
			
			# === Makefile variable replacement
			# just blank out ${ORIGIN}
			# That seems to be what the original extconf.rb build did.
			final_link_command.gsub! "${ORIGIN}", ''
			
			
			
			# === Display link command in terminal
			# (substitute [GEM_ROOT] for the root path, like in 'run_i')
			# (substitution is for display purposes only)
			puts "Performing final link..."
			puts final_link_command.gsub GEM_ROOT, '[GEM_ROOT]'
			
			
			# === Execute the final link
			run_i final_link_command
		end
		
		
		
		puts "Final link complete!"
	end
	
	private
	
	def load_extconf_data(path_to_yaml_dump)
		extconf_data = YAML.load_file(path_to_yaml_dump)
		extconf_variable_names, extconf_variable_hash = extconf_data
		
		return extconf_variable_hash
	end
	
	# Turns out, the output of the command 'gem env' is basically YAML.
	# As such, you can load that right up as a string,
	# in order to get information about the enviornemnt.
	def read_gem_env
		# --- Gotta do a little bit of reformatting of this data...
			# Top level data structure is an Array of Hash objects.
			# "flatten" it out, merging all hashes together,
			# and removing the containing Array.
		env = YAML.load `gem env`
		env = 
			env["RubyGems Environment"]
			.inject(Hash.new){ |hash, x|
				hash.merge! x
			}
		# p env
		
		return env
	end
	
	public
	
	
	
	
	
	def run_tests
		puts "=== running tests"
		
		symbols = self.methods.grep /test_/
		p symbols
		
		symbols.each do |sym|
			self.send sym
		end
	end
	
		# Check final dynamic libary for symbols that will only exist
		# when the final link is performed correctly.
		# desc "make sure final link works as expected (linux)"
		def test_final_link
			puts "--- testing: make sure final link has happened"
			
			# The test symbol sholud be something that only exists
			# in the base build, and not the project build.
			# Thus, the presense of this symbol in the final linked product
			# confirms that the link has succeded.
			
			
			# --- first, make sure the baseline lib actually exists
			#     (can't compare with something that's not there)
			path = Pathname.new(@so_paths[:wrapper])
			unless path.exist?
				raise "ERROR: Baseline lib not found @ #{path}"
			end
			
			
			# --- check the output location too
			path = Pathname.new(@so_paths[:final])
			unless path.exist?
				raise "ERROR: Dynamic lib from final link not found @ #{path}"
			end
			
			
			# --- perform the main checks
			sym      = "Launcher"
			test_cmd = "nm -C #{NAME}.so  | grep #{sym}"
			
			# baseline
			cmd1 = nil
			Dir.chdir(File.dirname(@so_paths[:wrapper])) do
				cmd1 = `#{test_cmd}` # run test command in shell
			end
			
			# final link
			cmd2 = nil
			Dir.chdir(File.dirname(@so_paths[:final])) do
				cmd2 = `#{test_cmd}` # run test command in shell
			end
			
			
			# p cmd1
			# p cmd2
			if cmd1.nil? or cmd2.nil?
				raise "ERROR: unexpected problem while inspecting final product."
			elsif cmd1 == ''
				raise "ERROR: symbol '#{sym}' not present in baseline lib."
			elsif cmd2 == '' # at this point, no error for baseline lib
				raise "ERROR: final .so did not contain symbol '#{sym}' as expected"
			else
				puts "no problems with final link"
			end
		end
		
		# Check if symbol is undefined, rather than merely if it is present.
		# desc "Make sure app factory has been linked into final product (linux)"
		def test_app_factory_link
			puts "--- testing: looking for 'app factory' symbol"
	
			sym      = "appFactory_create"
			test_cmd = "nm -C #{NAME}.so  | grep #{sym}"
			
			
			out = nil
			
			Dir.chdir(File.dirname(@so_paths[:final])) do
				out = `#{test_cmd}`
			end
			
			
			
			
			if out.nil?
				raise "ERROR: unexpected problem while inspecting final product."
			elsif out == ''
				raise "ERROR: symbol '#{sym}' not found in final dynamic library"
			elsif out.include? 'U'
				# ex)  U appFactory_create(Rice::Object)
				raise "ERROR: symbol '#{sym}' found, but was undefined"
			else
				# No problems!
				puts "no problems - appFactory linked correctly"
			end
		end
	
	
	
	# desc "move completed dynamic library to final location (linux)"
	# task :install do
	def install
		puts "=== install"
		
		src = @so_paths[:final]
		dst = @so_paths[:install]
		
		puts "Moving completed dynamic library to '#{dst}'".gsub(GEM_ROOT, "[GEM_ROOT]")
		# copy dynamic lib into final location
		FileUtils.mkdir_p(Pathname.new(dst).dirname)
		FileUtils.cp(src, dst)
	end
	
	
	
	
	# ------------------------
	
	def main
		Monad.maybe_e self, [
			[:create_data_path_file],
			[:build],
			[:link],
			[:run_tests],
			[:install],
		]
	end
	
	def clean
		Dir.chdir(@app_path) do
			begin 
				run_i "make clean"
			rescue StandardError => e
				# FIXME: Can't seem to catch, suppress, and continue
				puts "nothing to clean for #{@app_path}"
			end
		end
		
		# clean files
		[
			@project_build_var_file,
			@data_path_file,
			@so_paths[:final],
			# @so_paths[:project], # should already be cleaned by 'make clean'
		].each do |filepath|
			FileUtils.rm filepath if File.exists? filepath
		end
		
		# clean directories
		[
			File.dirname(@data_path_file),
			File.dirname(@so_paths[:final])
		].each do |filepath|
			FileUtils.rm_rf filepath if Dir.exists? filepath
		end
	end
	
	def clobber
		self.clean
		
		# clobber files
		[
			@so_paths[:install],
			File.join(@app_path, "Makefile")
		].each do |file_to_be_cleaned|
			FileUtils.rm file_to_be_cleaned if File.exist? file_to_be_cleaned
		end
	end
	
end


end
end
